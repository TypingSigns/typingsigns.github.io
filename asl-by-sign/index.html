<!DOCTYPE html>
<html lang="en">
<head>

	<meta charset="UTF-8">

	<title>ASL Sign Search (Beta)</title>
	<meta name="description" content="Dictionary Lookup of ASL signs by handshapes, and movements.">

	<script src="js/jquery.min.js"></script>
	<script src="js/sifter.js"></script>
	<script src="js/2_sgn4.js"></script>
	<script src="js/swRootSymbolCategories.js"></script>
	<script src="/js/ga-track.js"></script>

	<!-- iOS Viewport --> <!-- Temporarily disabled as sizing isn't ready at this scale. -->
	<!-- <meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"> -->
	<meta name="apple-mobile-web-app-capable" content="yes">

	<link rel="stylesheet" href="stylesheet.css" type="text/css">

	<!-- Misc Future Potenital ToDos (no order):
		- Remove abc-alphabetical ordering of search terms. (once more keyboard-keys are in)
		- remove excessive unicode8 symbols, from the regex search of an FSW-string.
		- create a font of single-characters u8 symbols with corrected height.
		- Use own Server for rendering icons. Or pre-render and store them locally.
		- Add Chrome-Desktop-Only disclaimer if opened in Safari. (SAFARI has font-handling issues with SignWriting 2010)

		- Clean Up Code - starting with unifying the handling of table-generation (~ in a modularised form to still allow for flexibility)

		- Allow search terms to be encoded to URL, so they can be copied and pasted and searched-for again.

		- ++ move '+' (grasps) from ‚ö° too ¬ß (parents)
		- ~ custom scoring and grouping of results by their ~meaning (~gloss)
		- add in a generic 'Face' symbol button

		- ~ add relative positioning/direction for face-element-positions / movements - for easier search - if necessary

		- allow gloss-search with expanded (secondary+) meanings

		- ~ add basic iphone compatability: (Save to Screen, proper 'zoom' settings)
	 -->
</head>

<style>
#pager {
	line-height: 2em;
	background-color: rgba(0,0,0,0.2);
}
#pager div {
	display: inline-block;
}
.button {
	border: 1px solid gray;
	border-radius: 10px;
}
#pager .button {
	background-color: #eee;
	padding: 0 10px;
	margin: 5px;
}
</style>

<body>
	<div id="content-wrapper">
		<div id="upper-wrapper">
			<div id="upper-header">
				<div class="left"><a href="../index.html" id="#home-button">üè†Ô∏è</a></div>
				<div id="search-header" class="centre"></div>
				<!-- <div class="right">Help ‚ÑπÔ∏è</div> -->
			</div>
			<div id="results-text"></div>
			<div id="results"></div>
			<div id="pager">
				<div class="button prev-button"><a href="#" id="pager-back">‚Üê back</a></div>
				<div class="text">#</div>
				<div class="button next-button"><a href="#" id="pager-next">next ‚Üí</a></div>
			</div>
		</div>
		<div id="keyboard-area">
			<input id="inputArea" type="text" name="gloss-entry" placeholder="Tap Search Keys ‚¨á ...">
		</div>
		<div id="test-area">
			<div id="temp-svg-holder"></div>
		</div>
	</div>
</body>

<!-- GLOBAL FUNCTIONS & VARIABLES -->
<script>
	// variables
	var _searchResults = [];
	// Paging Mechanism
	var _page = 0; // as an index
	var _items_per_page = 42;
	function _getMaxPage() {
		if (!!!_searchResults.items) return 0;
		return Math.floor(_searchResults.items.length * 1.0 / _items_per_page);
	}

	// Global Function
	function findUnicode8SuttonSymbols(fsw) {

		// Remove the Marker-Sequence from FSW, e.g. "AS20350S20358S2eb00S2eb4cS2fb04" from "AS20350S20358S2eb00S2eb4cS2fb04M522x529S20350506x472S20358477x472S2fb04491x523S2eb00507x492S2eb4c477x492"

		// We assume 'A' is the first character. (^A)
		// We assume all FSW-BaseSymbols are only 5 digits long.
		// We currently assume no Punctuation-BaseSymbols are used (denoted with P instead of S)

		var markerSequences = fsw.match( /^A(S.{5})+/g );
		if (markerSequences) {
			var markerSequence = markerSequences[0];
			// remove markerSequence from fsw
			fsw = fsw.substring(markerSequence.length, fsw.length);
		}

		// MATCH S-BASE-SYMBOLS

		var symbols = fsw.match(/S.{5}/g);

		var u8symbols = [];
		for (var i=0; i<symbols.length; i++) {
			// Convert SignWriting Symbol Key - to Unicode
			var symbol = symbols[i];
			var hexkey = symbol.substring(1);
			hexkey = hexkey.substring(0, hexkey.length - 2); // Strip down to first 3 numbers (as that's all that's currently supported in unicode8)
			var hexvalue_dec = parseInt(hexkey, 16);

			var base_zeroValue_str = "1D700"; // because unicode8 starts at 1D800, and sw starts at 100.
			var unicodeHexValue_dec = hexvalue_dec + parseInt(base_zeroValue_str, 16);

			var u8 = String.fromCodePoint(unicodeHexValue_dec); // <- Ah I see, I wanted String.fromCodePoint, NOT fromCharCode!! - http://xahlee.info/js/js_unicode_code_point.html

			u8symbols.push(u8);
		}

		return u8symbols;
	}

	function numberToEmoji_emoji(number) {
		number = Math.round(number);
		if (number <0 || number > 10) { number = "#"; }
		if (number == 10) { return "üîü"; }
		return number+"‚É£";
	}
</script>


<!-- PRE-GENERATION FUNCTIONS -->
<script>
	// VALUES
	///////////////////////////////
	// HANDSHAPES
	var swHandshapeRoots = ["S10000", "S10e00", "S11e00", "S14400", "S14c00", "S18600", "S1a400", "S1ba00", "S1cd00", "S1f500"]; // default 1,2,3,4,5,6,7,8,9,10 order.
	var displayOrder_num = [1,9,2,3,4,5,10,6,7,8];

	var swroot_fiveHand_lookup = {
		1: "‚òù",
		9: "‚òù",
		2: "‚úå",
		3: "‚úå",
		4: "üñê",
		5: "üñê",
		10: "üëç",
		6: "ü§ò",
		7: "ü§ò",
		8: "ü§ò",
	}
	///////////////////////////////
	// GENERAL CONTACT
	var contactLevel0_singleSymbol = "‚ú≥Ô∏è";
	var contactLevel1 = [
		{'id':'touch|grasp|strike', 'children':['touch', 'grasp', 'strike'], 'rep':'‚ö°'},
		{'id':'brush|rub', 'children':['brush', 'rub'], 'rep':'üç•'},
		{'id':'between', 'children':['between'], 'rep':'¬ß'}
	];
	var contactLevel2 = [
		{'id':'touch', 'children':["S20500", "S20600", "S20700"], 'rep':'*'}, 
		{'id':'grasp', 'children':["S20800", "S20900", "S20a00"], 'rep':'+'},
		{'id':'strike', 'children':["S20b00", "S20c00", "S20d00"], 'rep':'#'},
		{'id':'brush', 'children':["S20e00", "S20f00", "S21000", "S21400", "S21500"], 'rep':'‚®Ä'}, // includes the odd symbols.
		{'id':'rub', 'children':["S21100", "S21200", "S21300"], 'rep':'@'},
		{'id':'between', 'children':["S20700", "S20a00", "S20d00", "S21000", "S21300"], 'rep':'¬ß'}
	]; // Note: this is custom, compared to the swRootSymbolCategories' generic categories
	
	///////////////////////////////
	// FINGER CONTACT
	var fingerContactLevel0_singleSymbol = "„ÄΩÔ∏è";
	var fingerContactLevel1 = [
		{'id':'squeeze|flick', 'children':["S21600", "S21700", "S21800", "S21900", "S21a00", "S21b00", "S21c00", "S21d00", "S21e00", "S21f00", "S22000"], 'rep':'‚Ä¢'}, 
		{'id':'hinge', 'children':["S22100", "S22200", "S22300", "S22400", "S22500", "S22600", "S22700", "S22800", "S22900"], 'rep':'^'}, // +fingerContactMovement
	];
	var fingerContactTable = '<table id="fingercontactlist">';
	
	///////////////////////////////////////////////////////////////////////////////////////////
	// PRINT swRootSymbolCategories:
	// console.log(swRootSymbolCategories);
	// // iterate through; replace with actualy symbol
	// for (var property in swRootSymbolCategories) {
	// 	console.log(property);
	// 	var property_swBaseSymbol = findUnicode8SuttonSymbols(property)[0];
	// 	console.log(property_swBaseSymbol);
	// 	if (swRootSymbolCategories.hasOwnProperty(property)) {
	// 		var subfsws = swRootSymbolCategories[property];
	// 		var sub_swbaseSymbols = [];
	// 		for (var i=0; i<subfsws.length; i++) {
	// 			var subfsw = subfsws[i];
	// 			var sub_swBaseSymbol = findUnicode8SuttonSymbols(subfsw)[0];
	// 			sub_swbaseSymbols.push(sub_swBaseSymbol);
	// 		}
	// 		console.log(subfsws);
	// 		console.log(sub_swbaseSymbols);
	// 	}
	// }

	///////////////////////////////
	// BODY PARTS
	// Going in inverse order

	// Face:
	var faceLevelA = [
		{'id':'HEAD', 		'rootSymbolCategory':'S2ff00', 'rep':'üîµ'},
		{'id':'EYEBROWS', 	'rootSymbolCategory':'S30a00', 'rep':'üëÄ'},
		{'id':'CHEEKS', 	'rootSymbolCategory':'S32a00', 'rep':'üå¨'},
		{'id':'MOUTH', 		'rootSymbolCategory':'S33b00', 'rep':'üëÑ'},
		{'id':'TONGUE', 	'rootSymbolCategory':'S35900', 'rep':'üëÖ'},
	];
	// fill with children, according to swRootSymbolCategories
	for (var i=0; i<faceLevelA.length; i++) {
		var e = faceLevelA[i];
		var swCategory = e['rootSymbolCategory'];
		var childrenBaseSw = swRootSymbolCategories[swCategory];
		e['children'] = childrenBaseSw;
	}
	var faceTableTree_3L1 = [ // ~ assuming for now a 3-level-tree with only 1 header element
		{
			'id':'FACE-ELEMENTS',
			'rep':'üòë',
			'children':faceLevelA
		}
	];

	// Upper Body
	var ubodyLevelA = [
		{'id':'TORSO', 		'rootSymbolCategory':'S36d00', 'rep':'üéΩ'},
		{'id':'LIMBS', 		'rootSymbolCategory':'S37600', 'rep':'üí™'},
	];
	// fill with children, according to swRootSymbolCategories
	for (var i=0; i<ubodyLevelA.length; i++) {
		var e = ubodyLevelA[i];
		var swCategory = e['rootSymbolCategory'];
		var childrenBaseSw = swRootSymbolCategories[swCategory];
		e['children'] = childrenBaseSw;
	}
	var ubodyTableTree_3L1 = [
		{
			'id':'UPPER-BODY',
			'rep':'üèã', //üëïÍÜúÏõÉ
			'children':ubodyLevelA
		}
	]

	///////////////////////////////
	// MOVEMENT // just using the signWriting-category-defaults for the time-being.
	var moveLevelA_swDefault = [
		{'id':'WALL-STRAIGHT', 	'swrootcat':'S22a00', 'rep': '‚ó´‚úõ'},
		{'id':'DIAGONAL',	 	'swrootcat':'S25500', 'rep': '‚ñ§‚ó´‚úØ'},
		{'id':'FLOOR-STRAIGHT',	'swrootcat':'S26500', 'rep': '‚ñ§‚úõ'},
		{'id':'WALL-CURVE', 	'swrootcat':'S28800', 'rep': '‚ó´‚ó°'},
		{'id':'WALL-HITTING', 	'swrootcat':'S2a600', 'rep': '‚ó´‚úØ'},
		{'id':'FLOOR-HITTING', 	'swrootcat':'S2b700', 'rep': '‚ñ§‚úØ'},
		{'id':'FLOOR-CURVE', 	'swrootcat':'S2d500', 'rep': '‚ñ§‚ó°'},
		{'id':'CIRCLE', 		'swrootcat':'S2e300', 'rep': 'üîÉ'},
	];
	// fill with children, according to swRootSymbolCategories
	for (var i=0; i<moveLevelA_swDefault.length; i++) {
		var e = moveLevelA_swDefault[i];
		var swCategory = e['swrootcat'];
		var childrenBaseSw = swRootSymbolCategories[swCategory];
		e['children'] = childrenBaseSw;
	}
	var moveTableTree_3L1 = [
		{
			'id':'MOVEMENT',
			'rep':'‚öõ',
			'children':moveLevelA_swDefault
		}
	]
	

	///////////////////////////////////////////////////////////////////////////////////////////
	// ONE-TIME GENERATION.
	// Create a ancestryLookup for swLeafSymbols from swRootSymbolCategories // At publication, can be ported to a separate js file.
	var swleaf_parents_lookup = {};
	// Add HandShapre Parent Symbols
	for (var i=0; i<swHandshapeRoots.length; i++) {
		var swroot_num = displayOrder_num[i];
		var swroot_fsw = swHandshapeRoots[swroot_num-1];
		var swroot_unicode = numberToEmoji_emoji(swroot_num);
		var fiveHand_emoji = swroot_fiveHand_lookup[swroot_num];

		var leafs = swRootSymbolCategories[swroot_fsw];
		for (var j=0; j<leafs.length; j++) {
			var leaf_fsw = leafs[j];
			var leaf_unicode = findUnicode8SuttonSymbols(leaf_fsw)[0];
			swleaf_parents_lookup[leaf_unicode] = [fiveHand_emoji, swroot_unicode];
		}
	}
	// Add Finger Contact Symbols
	var ancestor0_rep = fingerContactLevel0_singleSymbol;
	for (var i=0; i<fingerContactLevel1.length; i++) {
		var item = fingerContactLevel1[i];
		var ancestor1_rep = item.rep;
		var children = item.children;
		for (var c=0; c<children.length; c++) {
			var child_fsw = children[c];
			var child_u8 = findUnicode8SuttonSymbols(child_fsw)[0];
			swleaf_parents_lookup[child_u8] = [ancestor0_rep, ancestor1_rep];
			// ~ potential future todo: replicate twice if symbol is a 'multiple' symbol. - so multi-symbols don't get added to the 'single-symbol-search' when searching
		}
	}
	// Add General Contact Symbols
	// Sort of Create a tree - and assign at the same time
	var ancestor0_rep1 = contactLevel0_singleSymbol;
	for (var i=0; i<contactLevel1.length; i++) {
		var e = contactLevel1[i];
		for (var c=0; c<e.children.length; c++) {
			var c1child_id = e.children[c];
			// Brute force - don't have that much to iterate // If i was doing this properly; would've converted this to a tree structure (levels->tree function)
			for (var t=0; t<contactLevel2.length; t++) {
				var curNode = contactLevel2[t];
				if (curNode.id == c1child_id) {
					// set representation for all the leaf-children here
					for (var l=0; l<curNode.children.length; l++) {
						var leaf_fsw = curNode.children[l];
						var leaf_u8 = findUnicode8SuttonSymbols(leaf_fsw)[0];
						if (!swleaf_parents_lookup[leaf_u8]) { swleaf_parents_lookup[leaf_u8] = []; }
						swleaf_parents_lookup[leaf_u8] = swleaf_parents_lookup[leaf_u8].concat([ancestor0_rep1, e.rep, curNode.rep]);
					}
					break;
				}
			}
		}
	}

	// FUNCTION add tableTree_3L1 symbols to swleaf_parents
	function import_tableTree3L1Symbols_to_swleafParentsLookup(tableTree_3L1) {
		var ancester0_rep = tableTree_3L1[0].rep; // ensure ancester0_rep is this one
		for (var i=0; i<tableTree_3L1[0].children.length; i++) {
			var e = tableTree_3L1[0].children[i];
			var ancestor1_rep = e.rep;
			var children = e.children;
			for (var c=0; c<children.length; c++) {
				var leaf_fsw = children[c];
				var leaf_u8 = findUnicode8SuttonSymbols(leaf_fsw)[0];
				// Add Parents to Leaf-Lookup
				if (!swleaf_parents_lookup[leaf_u8]) { swleaf_parents_lookup[leaf_u8] = []; }
				swleaf_parents_lookup[leaf_u8] = swleaf_parents_lookup[leaf_u8].concat([ancester0_rep, ancestor1_rep]);
			}
		}
	}

	// Add Face Table Symbols
	import_tableTree3L1Symbols_to_swleafParentsLookup(faceTableTree_3L1);

	// Add UpperBody Table Symbols
	import_tableTree3L1Symbols_to_swleafParentsLookup(ubodyTableTree_3L1);

	// Add Movement Table Symbols
	import_tableTree3L1Symbols_to_swleafParentsLookup(moveTableTree_3L1);
	

	// Add SearchTerm (Updateable) (To be solidified as a separate file in Production)
	for (var i=0; i<signPuddleEntries.length; i++) {
		var entry = signPuddleEntries[i];
		if (entry.term != undefined) {
			var fsw = entry.term[0];
			if (typeof fsw !== 'object') { // weirdly enough, some entry.term don't contain an FSW, but do contain a 'mainLabel'
				// C. (adding parentLookup)
				var usymbols = findUnicode8SuttonSymbols(fsw);
				var parentSymbols = [];
				for (var j=0; j<usymbols.length; j++) {
					var s = usymbols[j];
					var parents = swleaf_parents_lookup[s];
					if (parents) {
						parentSymbols = [].concat(parentSymbols, parents);
					}
				}
				parentSymbols.sort();
				usymbols.sort();
				// C+. (~optional) (~adding mainLabel)
				var mainLabel = "";
				if (entry.term.length > 1) { mainLabel = entry.term[1].__cdata; }
				entry['unicode8searchTerms'] = usymbols.join("") + parentSymbols.join("");
				entry['mainLabel'] = mainLabel;
			}
		}
	}

</script>

<!-- CREATE KEYBOARD -->
<script>
	// TOGGLE Expanded/Collapsed Keyboard - BUTTON
	var displaySwLeavesButton_html = '<a href="#" id="displaySwLeavesButton" class="buttoned">ü§ì Expand / Collapse </a>'
	$('#keyboard-area').prepend(displaySwLeavesButton_html);
	$('#displaySwLeavesButton').click(function() {
		$('tr.u8symbols-row').toggle();
		updateUpperHeight();
	});

	// KEYBOARD TABLE(S):
	var tr = '';

	///////////////////////////////////////////////
	// TABLE-FORMATS CONVERSION FUNCTIONS

	function convert_tableTree3L1_to_tableArray3L1(tableTree_3L1) {
		// TURN 3-LEVEL-TREE-WITH-ONE-HEAD.json INTO Table-Array
		var table_3L = tableTree_3L1[0]; // assuming a 3Level tree - with Only one Head
		var table_arr = new Array(3);
		var children = table_3L.children;
		var table_rep = table_3L.rep;
		var tr0td0_rep = '<a href="#" class="ku8ancestor" string="'+table_rep+'">' + table_rep + '</a>'
		table_arr[0] = {'cells':[{'rep':tr0td0_rep, 'colspan':children.length}]}; // <- on deeper levels, ColSpan would be fed upwards.
		table_arr[1] = {'cells':[]};
		table_arr[2] = {'class':'u8symbols-row', 'cells':[]};
		// table_arr[2] = {'cells':[]}; // ~ temp unclassed - so we can see
		for (var i=0; i<children.length; i++) {
			var e = children[i];
			var rep = e.rep;
			var leaves = e.children;

			// Level 1 Representation
			var level1td_html = '<a href="#" class="ku8ancestor" string="'+rep+'">' + rep + '</a>';
			var level1_td = {'rep':level1td_html};
			table_arr[1].cells.push(level1_td);

			// Level 2 (Leaf) Representation
			var level2_td = {'rep':leaves.join(' ')};
			var children_html = '<div class="unicode-symbols">'
			for (var h=0; h<leaves.length; h++) {
				var child_fsw = leaves[h];
				var child_u8symbol = findUnicode8SuttonSymbols(child_fsw)[0];
				var id = 'k' + child_fsw;
				children_html += '<a href="#" class="kleafsymbol" id="'+id+'" string="'+child_u8symbol+'"><span>'+child_u8symbol+'</span></a> ';
			}
			children_html += '</div>';
			// table_arr[2].cells.push( {'rep':leaves.join(' ')} ); 
			table_arr[2].cells.push( {'rep':children_html} ); 
		}
		return table_arr;
	}

	function convert_tableArray3L1_to_tdHtml(table_arr) {
		// Turn Table-Array-3-Level into Actual Table // Assumes a 3-level-array-representing-table
		var rows_html = "";
		for (var i=0; i<table_arr.length; i++) {
			var row = table_arr[i];
			var class_html = row.class?(' class="'+row.class+'"'):'';
			var row_html = '<tr' + class_html + '>';
			var cols = row.cells;
			for (var j=0; j<cols.length; j++) {
				var cell = cols[j];
				var colspan_html = cell.colspan?(' colspan="'+cell.colspan+'"'):'';
				var cell_html = '<td'+colspan_html+'>';
				cell_html += cell.rep;
				cell_html += '</td>'
				row_html += cell_html;
			}
			row_html += '</tr>\n'
			rows_html += row_html;
		}
		return rows_html;
	}


	///////////////////////////////////////////////
	// MOVE TABLE
	var moveTable = '<table id="movelist">';
	var moveTable3L1_arr = convert_tableTree3L1_to_tableArray3L1(moveTableTree_3L1);
	moveTable += convert_tableArray3L1_to_tdHtml(moveTable3L1_arr);
	moveTable += '</table>';


	///////////////////////////////////////////////
	// FACE TABLE
	var faceTable = '<table id="facelist">';
	var faceTable3L1_arr = convert_tableTree3L1_to_tableArray3L1(faceTableTree_3L1);
	faceTable += convert_tableArray3L1_to_tdHtml(faceTable3L1_arr);
	faceTable += '</table>';


	///////////////////////////////////////////////
	// UPPERBODY TABLE
	var ubodyTable = '<table id="ubodylist">';
	var ubodyTable3L1_arr = convert_tableTree3L1_to_tableArray3L1(ubodyTableTree_3L1);
	ubodyTable += convert_tableArray3L1_to_tdHtml(ubodyTable3L1_arr);
	ubodyTable += '</table>';
	

	///////////////////////////////////////////////
	// CONTACT TABLE
	var contactTable = '<table id="contactlist">';
	// var tr = '';
	// Add Level0-Header (custom - over 6 columns)
	tr = '<tr>';
	tr += '<td colspan="6"><a href="#" class="ku8ancestor" string="'+contactLevel0_singleSymbol+'">' + contactLevel0_singleSymbol + '</a></td>';
	tr += '</tr>';
	contactTable += tr;
	// Add Level1-Headers (currently assume, in correct order)
	tr = '<tr>';
	for (var i=0; i<contactLevel1.length; i++) {
		var item = contactLevel1[i];
		var html = '<td colspan="'+item.children.length+'"><a href="#" class="ku8ancestor" string="'+item.rep+'">' + item.rep + '</a></td>';
		tr += html;
	}
	tr += '</tr>';
	contactTable += tr;
	// Add Leaf-Headers (level2)
	tr = '<tr>';
	for (var i=0; i<contactLevel2.length; i++) {
		var item = contactLevel2[i];
		var html = '<td><a href="#" class="ku8ancestor" string="'+item.rep+'">' + item.rep + '</a></td>';
		tr += html;
	}
	tr += '</tr>';
	contactTable += tr;
	// Add Leaf-Content (level2)
	tr = '<tr class="u8symbols-row">';
	for (var i=0; i<contactLevel2.length; i++) {
		var item = contactLevel2[i];
		var children_html = '<div class="unicode-symbols">'
		for (var h=0; h<item.children.length; h++) {
			var child_fsw = item.children[h];
			var child_u8symbol = findUnicode8SuttonSymbols(child_fsw)[0];
			var id = 'k' + child_fsw;
			children_html += '<a href="#" class="kleafsymbol" id="'+id+'" string="'+child_u8symbol+'"><span>'+child_u8symbol+'</span></a> ';
		}
		children_html += '</div>';
		tr += "<td>"+children_html+"</td>";
	}
	tr += '</tr>';
	contactTable += tr;

	// Add Table
	contactTable += '</table>';

	
	///////////////////////////////
	// FINGER CONTACT
	// Add Level0-Header (custom - over 2 columns)
	tr = '<tr>';
	tr += '<td colspan="2"><a href="#" class="ku8ancestor" string="'+fingerContactLevel0_singleSymbol+'">' + fingerContactLevel0_singleSymbol + '</a></td>';
	tr += '</tr>';
	fingerContactTable += tr;
	// Add Leaf-Headers (level1)
	tr = '<tr>';
	for (var i=0; i<fingerContactLevel1.length; i++) {
		var item = fingerContactLevel1[i];
		var html = '<td><a href="#" class="ku8ancestor" string="'+item.rep+'">' + item.rep + '</a></td>';
		tr += html;
	}
	tr += '</tr>';
	fingerContactTable += tr;
	// Add Leaf-Content (level1)
	tr = '<tr class="u8symbols-row">';
	for (var i=0; i<fingerContactLevel1.length; i++) {
		var item = fingerContactLevel1[i];
		// var children_u8symbol = [];
		var children_html = '<div class="unicode-symbols">'
		for (var h=0; h<item.children.length; h++) {
			var child_fsw = item.children[h];
			var child_u8symbol = findUnicode8SuttonSymbols(child_fsw)[0];
			// children_u8symbol.push(child_u8symbol);
			var id = 'k' + child_fsw; //~
			children_html += '<a href="#" class="kleafsymbol" id="'+id+'" string="'+child_u8symbol+'"><span>'+child_u8symbol+'</span></a> ';
		}
		children_html += '</div>';
		// var html = '<td>' + children_u8symbol.join(" ") + '</td>';
		// tr += html;
		tr += "<td>"+children_html+"</td>";
	}
	tr += '</tr>';
	fingerContactTable += tr;

	// Add Table
	fingerContactTable += '</table>';



	////////////////////////////////////////////////////////////////

	// HAND TABLE

	// LOAD BUTTONS // p.s. 2016-10-11 - a lot of 'id' tags are no longer used in handTable
	var handTable = '<table id="handlist">';
	// Populate 5-Hand-Categories
	var fiveHandCategories_tableFormat = [
		{"emoji":"‚òù", "colspan":"2", "index":0},
		{"emoji":"‚úå", "colspan":"2", "index":1},
		{"emoji":"üñê", "colspan":"2", "index":2},
		{"emoji":"üëç", "colspan":"1", "index":3},
		{"emoji":"ü§ò", "colspan":"3", "index":4},
	];
	tr = '<tr id="fiveHandCategories">';
	for (var i=0; i<fiveHandCategories_tableFormat.length; i++) {
		var e = fiveHandCategories_tableFormat[i];
		var cha = '<span class="buttoned">'+e.emoji+'</span>'
		var html = '<a href="#" class="ku8ancestor" id="kfh'+e.index+'" string="'+e.emoji+'">'+cha+'</a>'
		tr += '<td colspan="'+ e.colspan +'">' + html + '</td>';
	}
	handTable += tr;
	// Populate SW_Root Row
	tr = '<tr id="swroot">';
	for (var i=0; i<displayOrder_num.length; i++) {
		var swHandshapeRoots_id = displayOrder_num[i]-1;
		var swroot = swHandshapeRoots[swHandshapeRoots_id];
		var numberSymbol_html = numberToEmoji_emoji(swHandshapeRoots_id+1);
		var td = "<td>"+'<a href="#" class="ku8ancestor" id="kswr'+displayOrder_num[i]+'" string="'+numberSymbol_html+'">'+numberSymbol_html+"</div></td>";
		tr += td;
	}
	tr += "</tr>";
	handTable += tr;
	// Populate Sub-Symbols Row
	tr = '<tr id="kleafsymbols" class="u8symbols-row">';
	for (var i=0; i<displayOrder_num.length; i++) {
		var swHandshapeRoots_id = displayOrder_num[i]-1;
		var swroot = swHandshapeRoots[swHandshapeRoots_id];
		
		var childSymbols = swRootSymbolCategories[swroot];
		var html = '<div class="unicode-symbols">'
		for (var j=0; j<childSymbols.length; j++) {
			var childSymbol = childSymbols[j];
			var usymbol = findUnicode8SuttonSymbols(childSymbol)[0];
			var id = 'k'+childSymbol;
			html += '<a href="#" class="kleafsymbol" id="'+id+'" string="'+usymbol+'"><span>'+usymbol+'</span></a> ';
		}
		html += '</div>'

		tr += "<td>"+html+"</td>";
	}
	tr += "</tr>";
	handTable += tr;
	handTable += "</table>"


	///////////////////////////////////////////////
	// ADD TABLES TO DOM
	$('#keyboard-area').append(handTable);
	$('#keyboard-area').append(faceTable);
	$('#keyboard-area').append(ubodyTable);
	$('#keyboard-area').append(contactTable);
	$('#keyboard-area').append(fingerContactTable);
	$('#keyboard-area').append(moveTable);
	


	///////////////////////////////////////////////
	// Add Click-Actions TO KEYBOARD-DOM-ELEMENTS
	$('.kleafsymbol').on('click', function(e) {
		e.preventDefault();
		var string = $(this).attr('string');
		appendToSearchField(string);
		// var symbol_str = $(this).attr('id');
		// var symbol_unicode = findUnicode8SuttonSymbols(symbol_str)[0];
		// appendToSearchField(symbol_unicode);
	});
	$('.ku8ancestor').on('click', function(e) {
		e.preventDefault();
		var string = $(this).attr('string');
		appendToSearchField(string);
	});
	function appendToSearchField(value) { //or addToInputArea
		var inputVal = $('#inputArea').val();
		var oldVal = inputVal;
		var newVal =  oldVal + value;
		$('#inputArea').val(newVal);

		refreshSearchResults();
	}
</script>

<!-- PAGING BUTTONS -->
<script>
	$('#pager-back').click(function() {
		_page = Math.max(_page-1, 0);
		refreshPage();
	});
	$('#pager-next').click(function() {
		_page = Math.min(_page+1, _getMaxPage()); // maxPage-1 ~
		refreshPage();
	});
</script>

<!-- DYNAMIC FUNCTIONS -->
<script>
	// Via: http://stackoverflow.com/questions/21397316/split-javascript-string-into-array-of-codepoints-taking-into-account-surrogat
	String.prototype.toCodePoints = function() {
	    chars = [];
	    for (var i= 0; i<this.length; i++) {
	        var c1= this.charCodeAt(i);
	        if (c1>=0xD800 && c1<0xDC00 && i+1<this.length) {
	            var c2= this.charCodeAt(i+1);
	            if (c2>=0xDC00 && c2<0xE000) {
	                chars.push(0x10000 + ((c1-0xD800)<<10) + (c2-0xDC00));
	                i++;
	                continue;
	            }
	        }
	        chars.push(c1);
	    }
	    return chars;
	}
	//

	// ON Load
	var sifter = new Sifter(signPuddleEntries); // Create Sifter
	refreshSearchResults(); // On Load // ~temp

	// Input Area
	$('#inputArea').focus();
	$('#inputArea').on('input', function(e) {
		e.preventDefault();
		refreshSearchResults();
	})

	// Search Term
	function getSearchTerms() {
		// Get Value
		var value = $('#inputArea').val();
		value = value.trim();
		if (value == "") {value = ""; } //" ùß´"; } // ~temp

		// DIVIDE UP STRING BY CODEPOINTS - AND EXTRACT SEARCH TERMS
		var codePoints = value.toCodePoints();
		// ^ CodePoints seem to work well - just gotta figure out how to convert them back to unicode. // Especially the complex ones

		var searchWords = [];
		var wordBuffer = [];
		for (var i=0; i<codePoints.length; i++) {
			var codePoint = codePoints[i];
			
			// HANDLE STANDARD CHARACTERS (Including AZ, 0-9, etc.)
			if (codePoint < 254 && codePoint != "¬ß".codePointAt(0)) {
				wordBuffer.push(codePoint);
				if (i == codePoints.length-1) { // Handle if this was the last character
					var bufferedWord = String.fromCodePoint.apply(this, wordBuffer);
					searchWords.push(bufferedWord);
				}
				continue;
			}
			// HANDLE END-NUMPAD-CODEPOINT - pulling from 'WORDS'
			if (codePoint == 8419) { // this is the 'combining-numpad'-character // Also adding the other one
				wordBuffer.push(codePoint);
				// Assuming it only requires the previous character. 
				if (wordBuffer.length > 2) {
					var wordBufferHead = wordBuffer.splice(0, wordBuffer.length-2); // splice simultaneously removes items, and returns removed items
					var bufferedWordHead = String.fromCodePoint.apply(this, wordBufferHead);
					searchWords.push(bufferedWordHead);
				}

				var bufferedWord = String.fromCodePoint.apply(this, wordBuffer); // <- This is how we feed multiple parametres into a function
				searchWords.push(bufferedWord);
				wordBuffer = [];
				continue;
			}
			// HANDLE 8* EMOJI CASE
			if (codePoint == 10035) {
				var nxtCodePoint = codePoints[i+1];
				if (nxtCodePoint == 65039) {
					// Add to search word
					var searchPicto = String.fromCodePoint(10035, 65039);
					searchWords.push(searchPicto);
					i += 1; // skip next codePoint
					continue;
				}
			}
			// HANDLE FINGER-MOVEMENT EMOJI CASE: „ÄΩÔ∏è
			if (codePoint == 12349) {
				var nxtCodePoint = codePoints[i+1];
				if (nxtCodePoint == 65039) {
					// Add to search word
					var searchPicto = String.fromCodePoint(12349, 65039);
					searchWords.push(searchPicto);
					i += 1; // skip next codePoint
					continue;
				}
			}

			// At this point, the codePoint is neither Standard nor handled as one of the special cases above:
				//End the WordBuffer and record the Word to search terms. (For when an english word is typed)
				if (wordBuffer.length != 0) {
					var bufferedWord = String.fromCodePoint.apply(this, wordBuffer);
					searchWords.push(bufferedWord);
					wordBuffer = [];
				}
				// Simply add the current non-standard, non-handled, unique codePoint as a straightforward searchWord
				var unicodeSequence = String.fromCodePoint(codePoint);
				searchWords.push(unicodeSequence);
		}
		
		// Sequencify Strings - so we're sensitive to replicated Base/ParentSymbols .
		searchWords.sort();
		var prvString = null;
		for (var i=0; i<searchWords.length; i++) {
			var string = searchWords[i];
			if (string == prvString) {
				// delete current item
				searchWords.splice(i,1);
				i--;
				// set the previous word to add another version of itself
				searchWords[i] = searchWords[i] + string;
			}
			prvString = string; // set to the singleWord, not the word-sequence
		}

		return searchWords;
	}

	// Update Results
	function refreshSearchResults() {
		// Reset page to 0
		_page = 0;

		var searchTerms = getSearchTerms();
		var value = searchTerms.join(" ");
		

		// Iniiate a sift search
		var results = sifter.search(value, {
			fields: ['mainLabel', 'unicode8searchTerms'],
			// sort: [{field: "mainLabel", direction:"asc"], // sifter.js only uses this sort for items with the same score, and scoring can't be easily disabled atm.
			conjunction: "and",
		});

		// TEMP: Filtering out items with no main label (this should be done in pre-processed data)
		for (var i=0; i<results.items.length; i++) {
			var _id = results.items[i].id;
			var entry = sifter.items[_id];

			var mainLabel = entry.mainLabel;
			if (!mainLabel) {
				results.items.splice(i, 1); // remove 1 item
				i--; // decrement i
			}
		}

		// TEMP: Sort Alphabetically by ABC // TEMP-DEBUG: sort results by main label - temporarily useful for navigating searches based on SignSymbols - so they have a logical ordering. SignSymbols should actually be able to be filtered by mode symbols - when we introduce these, we can remove this function.
		function sort_withNumbersAfterLetters(a,b) {
			// can just ad zzz in front
			var a1 = a.charAt(0);
			var b1 = b.charAt(0);
			if ( $.isNumeric(a1) ) { a = "Œ©" + a; }
			if ( $.isNumeric(b1) ) { b = "Œ©" + b; }
			return a.localeCompare(b);
		}
		function compareResultItem_mainLabel(a, b) {
			var aid = a.id;
			var bid = b.id;
			var aEntry = sifter.items[aid];
			var bEntry = sifter.items[bid];
			var aLabel = aEntry.mainLabel;
			var bLabel = bEntry.mainLabel;
			// return aLabel.localeCompare(bLabel);
			return sort_withNumbersAfterLetters(aLabel, bLabel);
		}
		// results.items.sort(compareResultItem_mainLabel);

		_searchResults = results;

		// UPDATE SEARCH HEADER
		var searchHeaderText = "";
		if (searchTerms.length >0 ) {
			var count = results.items.length + '';
			count = count.replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,");
			searchHeaderText = searchTerms + " ‚Äì " + count + " results";
		} else {
			var count = signPuddleEntries.length + '';
			count = count.replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,");
			searchHeaderText = "Look up the gloss for " + count + " Signs";
		}
		$('#search-header').text(searchHeaderText);

		// REFRESH PAGE
		refreshPage();
	}

	function refreshPage() {
		var results = _searchResults;
		// DISPLAY

		// Update Texts:
		// var displayText = "Displaying "+_items_per_page+" of "+results.items.length+" signs. (Search terms need to be separated by spaces \" \".) (Chrome required to view.)";
		// $('#results-text').text(displayText);
		$('#results-text').text("");
		var lastItemNumber = Math.min((_page+1) * _items_per_page, results.items.length);
		var pagerText = "Last Item: #"+lastItemNumber+"/"+results.items.length;
		pagerText += ". " + "Page "+(_page+1)+" of "+(_getMaxPage()+1);
		$('#pager .text').text(pagerText);

		var startingId = _page * _items_per_page;
		var endingId = Math.min(startingId + _items_per_page, results.items.length);

		// Display Results
		var resultsHtml = '';
		var symbolTagsOnPage = [];
		for (var i=startingId; i<endingId; i++) {

			var _id = results.items[i].id;
			var entry = sifter.items[_id];
			var id = entry._id;
			if (entry.term.length == undefined) {continue;}

			// console.log(entry);

			var fsw = entry.term[0];
			var mainLabel = entry.mainLabel;
			if (!mainLabel) { mainLabel = "‚Ä¶?‚Ä¶"; }
			var symbols = findUnicode8SuttonSymbols(fsw);
			symbols.sort(); // display symbols alphabetically
			// var symbolsString = symbols.join('');
			// var symbolsString = '<span><a href="#">'+symbols.join('</a></span><span><a href="#">')+'</a></span>'
			var symbolsString = "";
			for (var s=0; s<symbols.length; s++) {
				var symbol = symbols[s];
				var symbolHtml = '<span><a href="#" class="symbol-tag symbol-'+symbol+'" u8baseSymbol="'+symbol+'">'+symbol+'</a></span>';
				symbolsString += symbolHtml;
				symbolTagsOnPage.push(symbol);
				// brute force binding click // should move to somewhere more efficient later
				// $(".symbol-"+symbol).unbind().click(function() {
				// 	console.log(symbol);
				// 	console.log("---");
				// });
			}
			var signPuddleLink = "http://www.signbank.org/signpuddle2.0/searchword.php?ui=1&sgn=4&sid="+id;

			var descriptionHtml = '<div class="description">'
			descriptionHtml += '<span class="main-label">' + '<a href="'+signPuddleLink+'" target="_blank">' + mainLabel + '</a>' + '</span>';
			// divHtml += '<span class="usymbols">' + entry.unicode8searchTerms + '</span>';
			descriptionHtml += '<span class="usymbols">' + symbolsString + '</span>'; // <- Weirdly enough, in Safari, this is the only config that really works. (xx.join(), xx.join('</span><span>') xx.join(' ') ) - it's the same even if it's changed to a <div> container // Assigning CSS Content:Before doesn't work either.
			descriptionHtml += '</div>'

			var divHtml = '<div id="e'+id+'" class="entry">';
			divHtml += '<div class="svg-wrapper"></div>'
			divHtml += descriptionHtml;
			divHtml += '</div>';
			resultsHtml += divHtml;

			// Load SVG
			loadSvgToEntry(id, fsw, entry.unicode8searchTerms);

		}
		$('#results').html(resultsHtml);

		$('.symbol-tag').unbind().click(function(e) {
			e.preventDefault();
			var schar = $(this).attr('u8baseSymbol');
			appendToSearchField(schar);
		})
	}

	function svgToPng_uri(rawSVG, callback) {
		
		var canvas = document.createElement('canvas');
		var canvasId = 'canvas-'+($('cavans').length+1);
		canvas.id = canvasId;
		// document.body.appendChild(canvas); // unnecessary

		// DETERMINE IMAGE SIZE
		// Version 2016-10-early - when SignWriting Server had no width/height specifications. Erroneous as of 2016-10-17 - when the viewbox is set to large.
		// ~ add to 'temp-svg-holder'
		// H: This code-block-version remains here until we stop relying on SW-Server
		// $('#temp-svg-holder').html(rawSVG);
		// var svg = document.getElementById('temp-svg-holder').firstChild;
		// var bbox = svg.getBBox(); //bbox.width, .height
		// var width = bbox.width;
		// var height = bbox.height;
		// console.log(width, height);
		// Version 2016-10-17 - when SignWriting Server's SVG's now have width and height specifications.
		var svg = $.parseHTML(rawSVG);
		var width = $(rawSVG).attr('width');
		var height = $(rawSVG).attr('height');

		// Set CANVAS SIZE
		canvas.width = width;
		canvas.height = height;

		// Canvas Context
		var ctx = canvas.getContext("2d");

		// DRAW INLINE SVG
		// via: http://stackoverflow.com/questions/27230293/how-to-convert-svg-to-png-using-html5-canvas-javascript-jquery-and-save-on-serve
	    var svg = new Blob([rawSVG], {type:"image/svg+xml;charset=utf-8"}),
	        domURL = self.URL || self.webkitURL || self,
	        url = domURL.createObjectURL(svg),
	        img = new Image;
	    img.onload = function () {
	        ctx.drawImage(this, 0,0);
	        domURL.revokeObjectURL(url);

	        var pngURI = canvas.toDataURL();
	        callback(pngURI);

	    };
	    img.src = url;
	}

	function loadSvgToEntry(id, fsw, unicode8searchTerms) {
		// var url = "https://swserver.wmflabs.org/svg/";
		var url = "asl-svgs-201610/"; // cross-origin issues
		url += fsw;
		// Load SVG
		var request = $.get(url);
		request.success(function(data) {
			// var svgHtml = data.firstChild.outerHTML;
			var svgHtml = data;

			// console.log(svgHtml);
			// console.log('---');

			// Set ENTRY Data
			$('#e'+id).attr("search-terms", unicode8searchTerms);
			$('#e'+id+' .svg-wrapper').html(svgHtml);
			$('#e'+id+' .svg-wrapper').addClass("loaded-svg");
			$('#e'+id+' .svg-wrapper').attr("fsw", fsw);

			// LOAD SVG
			svgToPng_uri(svgHtml, function(uri) {
				var imgHtml = '<img src="'+uri+'">';
				$('#e'+id+' .svg-wrapper').append(imgHtml)
			});
		});
		request.error(function(jqXHR, statusText) {
			$('#e'+id+' .svg-wrapper').addClass("load-unsuccessful");
			// console.log(url, statusText);
		});
	}

</script>

<!-- HEIGHT CHECK -->
<script>

	heightCheck();

	// RESIZE Handling
	$( window ).resize(function() {
		heightCheck();
	});
	function heightCheck() {
		// Height Check
		var mainHeight = $('#content-wrapper').outerHeight(); // same as windowHeight // $(window).height();

		$('tr.u8symbols-row').show();
		$('displaySwLeavesButton').show();

		var keyboardHeight_current = $('#keyboard-area').outerHeight();
		$('tr.u8symbols-row').hide();
		var keyboardHeight_withoutLeafs = $('#keyboard-area').outerHeight();
		$('tr.u8symbols-row').show();
		var keyboardHeight_withLeafs = $('#keyboard-area').outerHeight();

		$('tr.u8symbols-row').show();
		$('displaySwLeavesButton').show();

		if (keyboardHeight_withLeafs > mainHeight*0.75) {
			// HIDE MODE
			$('tr.u8symbols-row').hide();
			keyboardHeight_current = $('#keyboard-area').outerHeight();
		}

		// TEMP: DEBUG:
			$('table.debug tr.u8symbols-row').show(); // ~ // DEBUG
		
		updateUpperHeight();
	}
	function updateUpperHeight() {
		var mainHeight = $('#content-wrapper').outerHeight(); // same as windowHeight // $(window).height();

		var keyboardHeight_current = $('#keyboard-area').outerHeight();

		// Update height // (this seems convoluted/annoying in css, hence the js)
		var upperHeight = parseInt(mainHeight - keyboardHeight_current);
		$('#upper-wrapper').height(upperHeight);	
	}

</script>

</html>